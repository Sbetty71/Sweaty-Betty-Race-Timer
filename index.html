<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sweaty Betty Race Timer</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        /* Ensure the main container is centered and responsive */
        #app-container {
            max-width: 800px;
            width: 100%;
            background-color: #ffffff;
            border-radius: 12px; /* Rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        /* Style for buttons */
        .btn {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .btn-primary {
            background-color: #4CAF50; /* Green for start */
            color: white;
        }
        .btn-primary:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .btn-secondary {
            background-color: #008CBA; /* Blue for record */
            color: white;
        }
        .btn-secondary:hover {
            background-color: #007bb5;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .btn-stop {
            background-color: #ff9800; /* Orange for stop */
            color: white;
        }
        .btn-stop:hover {
            background-color: #fb8c00;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .btn-reset {
            background-color: #f44336; /* Red for reset */
            color: white;
        }
        .btn-reset:hover {
            background-color: #da190b;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .btn-stop.holding, .btn-reset.holding {
            background-color: #e65100; /* Darker orange while holding */
        }
        #recordButton {
            width: 100%;
            font-size: 2rem;
            padding: 40px;
        }
        /* Timer display styling */
        #timer-display {
            font-size: 3.5rem; /* Larger font for timer */
            font-weight: 700;
            color: #2c3e50; /* Darker text */
            margin-bottom: 20px;
            background-color: #ecf0f1; /* Light gray background for timer */
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        /* Table styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            overflow: hidden; /* Ensures rounded corners apply to table content */
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #34495e; /* Dark blue for table header */
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9; /* Light stripe for even rows */
        }
        tr:hover {
            background-color: #f1f1f1; /* Highlight on hover */
        }
        /* Responsive adjustments */
        @media (max-width: 640px) {
            #timer-display {
                font-size: 2.5rem;
            }
            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
            #app-container {
                padding: 20px;
            }
        }
        #user-id-display, #race-id-display, #join-status {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #555;
            word-wrap: break-word; /* Allows long IDs to wrap */
        }
        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
        }
        .input-group input {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #ccc;
            outline: none;
            transition: border-color 0.2s;
            width: 150px;
        }
        .input-group input:focus {
            border-color: #4CAF50;
        }

        /* Keyframe animation for the flash effect */
        @keyframes flashEffect {
            0% { background-color: #008CBA; }
            50% { background-color: #4CAF50; } /* Flash to a different color */
            100% { background-color: #008CBA; }
        }

        /* Class to apply the flash effect */
        .btn-secondary.flash {
            animation: flashEffect 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <h1 class="text-4xl font-bold text-gray-800 mb-6">Sweaty Betty Race Timer</h1>

        <div id="timer-display">00:00:00</div>

        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <button id="startButton" class="btn bg-gray-400 cursor-not-allowed" disabled>Connecting...</button>
            <button id="recordButton" class="btn btn-secondary" disabled>Record Finish</button>
            <button id="stopButton" class="btn btn-stop" disabled>Stop Race</button>
            <button id="resetButton" class="btn btn-reset" disabled>Reset</button>
        </div>

        <div id="status-messages" class="mt-4">
            <div id="status-indicator" class="text-sm font-semibold text-gray-700">Connecting to database...</div>
            <div id="user-id-display" class="text-sm text-gray-500"></div>
            <div id="race-id-display" class="text-sm text-gray-500 font-bold"></div>
            <div id="join-status" class="text-sm text-red-500"></div>
        </div>
        
        <hr class="my-6 border-gray-200">

        <h3 class="text-xl font-semibold text-gray-700">Join an Existing Race</h3>
        <div class="input-group">
            <input type="text" id="raceIdInput" placeholder="Enter Race ID" class="text-center">
            <button id="joinButton" class="btn btn-secondary" disabled>Join Race</button>
        </div>

        <hr class="my-6 border-gray-200">

        <h2 class="text-2xl font-semibold text-gray-700 mb-4">Finishers</h2>
        <div class="overflow-x-auto rounded-lg">
            <table id="resultsTable">
                <thead>
                    <tr>
                        <th>Finisher #</th>
                        <th>Time</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Results will be inserted here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, getDocs, deleteDoc, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyBIJYQf1JmJOgqGP4B0W6MqJCIhRsO9XKU",
  authDomain: "gemini-5k-timer.firebaseapp.com",
  projectId: "gemini-5k-timer",
  storageBucket: "gemini-5k-timer.firebasestorage.app",
  messagingSenderId: "452422143632",
  appId: "1:452422143632:web:6fd748202fa20f8056d215",
  measurementId: "G-GND0EZY2R3"
};    
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Get references to DOM elements
        const timerDisplay = document.getElementById('timer-display');
        const startButton = document.getElementById('startButton');
        const recordButton = document.getElementById('recordButton');
        const stopButton = document.getElementById('stopButton');
        const resetButton = document.getElementById('resetButton');
        const joinButton = document.getElementById('joinButton');
        const resultsTableBody = document.querySelector('#resultsTable tbody');
        const userIdDisplay = document.getElementById('user-id-display');
        const raceIdDisplay = document.getElementById('race-id-display');
        const raceIdInput = document.getElementById('raceIdInput');
        const joinStatus = document.getElementById('join-status');
        const statusIndicator = document.getElementById('status-indicator');

        let startTime;
        let timerInterval;
        let finisherCount = 0;
        let isRaceStarted = false;

        // Variables for hold-to-stop functionality
        let holdTimerId = null;
        let countdownIntervalId = null;
        const holdDuration = 3000;
        let countdownSeconds = 0;
        let isHoldingStop = false;
        let isHoldingReset = false;

        let db;
        let auth;
        let raceFinishersCollectionRef; // This will be dynamic
        let unsubscribeFromFirestore = null; // To store the unsubscribe function
        let currentRaceId = null; // To track the ID of the active race

        /**
         * Triggers a short vibration if the browser supports it.
         */
        function vibrate() {
            if (window.navigator && window.navigator.vibrate) {
                window.navigator.vibrate(50); // Vibrate for 50ms
            }
        }

        /**
         * Generates a random, short ID for a race.
         * @returns {string} A 6-character alphanumeric string.
         */
        function generateShortId() {
            const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }

        /**
         * Formats a given number of milliseconds into a human-readable time string (MM:SS:ms).
         * @param {number} ms - The time in milliseconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = Math.floor((ms % 1000) / 10);

            const pad = (num) => num.toString().padStart(2, '0');

            return `${pad(minutes)}:${pad(seconds)}:${pad(milliseconds)}`;
        }

        /**
         * Renders the finishers data in the table.
         * @param {Array<Object>} finishers - An array of finisher objects.
         */
        function renderFinishers(finishers) {
            while (resultsTableBody.firstChild) {
                resultsTableBody.removeChild(resultsTableBody.firstChild);
            }

            const sortedFinishers = finishers.sort((a, b) => a.finisherNumber - b.finisherNumber);

            sortedFinishers.forEach(finisher => {
                const newRow = resultsTableBody.insertRow();
                const finisherNumCell = newRow.insertCell();
                const timeCell = newRow.insertCell();

                finisherNumCell.textContent = finisher.finisherNumber;
                timeCell.textContent = formatTime(finisher.finishTime);
            });
            resultsTableBody.parentElement.scrollTop = resultsTableBody.parentElement.scrollHeight;
        }

        /**
         * Common logic to start the timer.
         */
        function startTimerLogic() {
            if (!isRaceStarted) {
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 10);
                isRaceStarted = true;
                startButton.disabled = true;
                recordButton.disabled = false;
                stopButton.disabled = false;
                resetButton.disabled = false;
                startButton.textContent = 'Race Started!';
                startButton.classList.remove('btn-primary');
                startButton.classList.add('bg-gray-400', 'cursor-not-allowed');
            }
        }

        /**
         * Common logic to stop the timer.
         */
        function stopTimerLogic() {
            if (isRaceStarted) {
                clearInterval(timerInterval);
                isRaceStarted = false;
                startButton.disabled = false;
                recordButton.disabled = true;
                stopButton.disabled = true;
                startButton.textContent = 'Ready to Go!';
                startButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                startButton.classList.add('btn-primary');
            }
        }
        
        /**
         * Updates the timer display every 10 milliseconds.
         */
        function updateTimer() {
            if (isRaceStarted) {
                const elapsedTime = Date.now() - startTime;
                timerDisplay.textContent = formatTime(elapsedTime);
            }
        }

        /**
         * Sets up the Firestore real-time listener for a given race ID.
         * @param {string} raceId - The ID of the race to listen to.
         */
        function setupFirestoreListener(raceId) {
            // Unsubscribe from any previous listener to avoid multiple updates
            if (unsubscribeFromFirestore) {
                unsubscribeFromFirestore();
            }
            
            statusIndicator.textContent = "Listening for race data...";

            raceFinishersCollectionRef = collection(db, `artifacts/${appId}/public/data/races/${raceId}/finishers`);
            currentRaceId = raceId; // Set the current active race ID

            // Start the new listener
            unsubscribeFromFirestore = onSnapshot(raceFinishersCollectionRef, (snapshot) => {
                const finishers = [];
                snapshot.forEach(doc => {
                    finishers.push(doc.data());
                });
                if (finishers.length > 0) {
                    finisherCount = Math.max(...finishers.map(f => f.finisherNumber));
                } else {
                    finisherCount = 0;
                }
                renderFinishers(finishers);
                statusIndicator.textContent = "Data synced!";
            }, (error) => {
                console.error("Error listening to finishers: ", error);
                statusIndicator.textContent = "Error loading data. Please refresh.";
            });
        }

        /**
         * Deletes all finishers from the current race collection in Firestore.
         */
        async function clearAllFinishers() {
            if (!currentRaceId) {
                console.error("Cannot clear finishers: No current race ID.");
                return;
            }
            statusIndicator.textContent = "Clearing all race finishers...";
            try {
                const finishersQuery = query(collection(db, `artifacts/${appId}/public/data/races/${currentRaceId}/finishers`));
                const querySnapshot = await getDocs(finishersQuery);
                const deletePromises = [];
                querySnapshot.forEach((doc) => {
                    deletePromises.push(deleteDoc(doc.ref));
                });
                await Promise.all(deletePromises);
                console.log("Successfully deleted all finishers for race:", currentRaceId);
                statusIndicator.textContent = "Finishers cleared from database!";
            } catch (error) {
                console.error("Error clearing finishers from Firestore: ", error);
                statusIndicator.textContent = "Error clearing data from database.";
            }
        }


        /**
         * Starts a new race by creating a session document in Firestore.
         */
        async function startNewRace() {
            vibrate();
            startButton.disabled = true;
            startButton.classList.remove('btn-primary');
            startButton.classList.add('bg-gray-400', 'cursor-not-allowed');
            startButton.textContent = 'Starting...';
            statusIndicator.textContent = "Creating new race session...";

            const newRaceId = generateShortId();
            const user = auth.currentUser;
            const raceDocRef = doc(db, `artifacts/${appId}/public/data/race-sessions/${newRaceId}`);

            // Use Promise.race to create a timeout for the Firestore operation
            const timeoutPromise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject(new Error("Timeout: Failed to start race. Please check your network and try again."));
                }, 5000); // 5-second timeout
            });

            try {
                // Wait for the Firestore operation to complete, or for the timeout to trigger
                await Promise.race([
                    setDoc(raceDocRef, {
                        hostUid: user.uid,
                        startedAt: Date.now()
                    }),
                    timeoutPromise
                ]);
                
                // If we reach here, the Firestore operation was successful
                setupFirestoreListener(newRaceId);
                raceIdDisplay.textContent = `Race ID: ${newRaceId}`;
                await clearAllFinishers();
                startTimerLogic();
                joinStatus.textContent = "";

            } catch (error) {
                console.error("Error starting a new race: ", error);
                joinStatus.textContent = error.message; // Display the error message
            } finally {
                // Always re-enable the button regardless of success or failure
                startButton.disabled = false;
                startButton.classList.add('btn-primary');
                startButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                startButton.textContent = 'Ready to Go!';
            }
        }

        /**
         * Attaches all main button event listeners after the app is initialized.
         */
        function attachEventListeners() {
            // Attach a single event listener to the start button that calls the new async function
            startButton.addEventListener('click', startNewRace);

            recordButton.addEventListener('click', async () => {
                vibrate();
                if (isRaceStarted) {
                    finisherCount++;
                    const finishTime = Date.now() - startTime;
                    try {
                        const currentRaceFinishersRef = collection(db, `artifacts/${appId}/public/data/races/${currentRaceId}/finishers`);
                        await addDoc(currentRaceFinishersRef, {
                            finisherNumber: finisherCount,
                            finishTime: finishTime,
                            timestamp: Date.now()
                        });

                        // Add the flash effect class and remove it after the animation duration
                        recordButton.classList.add('flash');
                        setTimeout(() => {
                            recordButton.classList.remove('flash');
                        }, 500); // 0.5 seconds
                    } catch (error) {
                        console.error("Error adding document: ", error);
                        finisherCount--;
                    }
                }
            });

            // Join Race button logic
            joinButton.addEventListener('click', async () => {
                vibrate();
                const enteredId = raceIdInput.value.trim().toLowerCase();
                if (enteredId.length === 6) {
                    joinStatus.textContent = 'Searching for race...';
                    try {
                        const raceDocRef = doc(db, `artifacts/${appId}/public/data/race-sessions/${enteredId}`);
                        const raceDocSnap = await getDoc(raceDocRef);

                        if (raceDocSnap.exists()) {
                            // Corrected: use the enteredId to set up the listener, not the host's UID.
                            setupFirestoreListener(enteredId);
                            joinStatus.textContent = `Joined race with ID: ${enteredId}`;
                            raceIdDisplay.textContent = `Race ID: ${enteredId}`;
                            // Reset timer and buttons to match joiner's state
                            stopTimerLogic();
                            startButton.disabled = true; // A joiner cannot start/stop the race
                            recordButton.disabled = false;
                            stopButton.disabled = false;
                            resetButton.disabled = true;
                        } else {
                            joinStatus.textContent = 'Race not found. Please check the ID.';
                        }
                    } catch (error) {
                        console.error("Error joining race: ", error);
                        joinStatus.textContent = 'Error joining race. Please try again.';
                    }
                } else {
                    joinStatus.textContent = 'Please enter a valid 6-character ID.';
                }
            });

            // Handlers for hold-to-stop
            stopButton.addEventListener('mousedown', () => {
                vibrate();
                if (isRaceStarted && !isHoldingStop) {
                    isHoldingStop = true;
                    stopButton.classList.add('holding');
                    countdownSeconds = holdDuration / 1000;
                    stopButton.textContent = `Hold to Stop (${countdownSeconds})`;
                    countdownIntervalId = setInterval(() => {
                        countdownSeconds--;
                        if (countdownSeconds > 0) {
                            stopButton.textContent = `Hold to Stop (${countdownSeconds})`;
                        } else {
                            stopButton.textContent = 'Stopping...';
                            clearInterval(countdownIntervalId);
                        }
                    }, 1000);
                    holdTimerId = setTimeout(() => {
                        stopTimerLogic();
                        isHoldingStop = false;
                        holdTimerId = null;
                        stopButton.textContent = 'Stop Race';
                        clearInterval(countdownIntervalId);
                    }, holdDuration);
                }
            });

            // Handlers for hold-to-reset
            resetButton.addEventListener('mousedown', () => {
                vibrate();
                if (!isHoldingReset && !isRaceStarted) {
                    isHoldingReset = true;
                    resetButton.classList.add('holding');
                    countdownSeconds = holdDuration / 1000;
                    resetButton.textContent = `Hold to Reset (${countdownSeconds})`;
                    countdownIntervalId = setInterval(() => {
                        countdownSeconds--;
                        if (countdownSeconds > 0) {
                            resetButton.textContent = `Hold to Reset (${countdownSeconds})`;
                        } else {
                            resetButton.textContent = 'Resetting...';
                            clearInterval(countdownIntervalId);
                        }
                    }, 1000);
                    holdTimerId = setTimeout(async () => {
                        await clearAllFinishers();
                        isHoldingReset = false;
                        holdTimerId = null;
                        resetButton.textContent = 'Reset';
                        clearInterval(countdownIntervalId);
                        location.reload();
                    }, holdDuration);
                }
            });


            // Common event listeners for canceling hold
            const cancelHold = (isTargetStop, isTargetReset) => {
                if (isTargetStop) isHoldingStop = false;
                if (isTargetReset) isHoldingReset = false;
                
                if (holdTimerId) {
                    clearTimeout(holdTimerId);
                    holdTimerId = null;
                }
                if (countdownIntervalId) {
                    clearInterval(countdownIntervalId);
                    countdownIntervalId = null;
                }
                if (isRaceStarted) {
                    stopButton.textContent = 'Stop Race';
                    stopButton.classList.remove('holding');
                }
                if (!isRaceStarted) {
                    resetButton.textContent = 'Reset';
                    resetButton.classList.remove('holding');
                }
            };

            stopButton.addEventListener('mouseup', () => cancelHold(true, false));
            stopButton.addEventListener('mouseleave', () => cancelHold(true, false));
            resetButton.addEventListener('mouseup', () => cancelHold(false, true));
            resetButton.addEventListener('mouseleave', () => cancelHold(false, true));
            document.addEventListener('touchend', () => cancelHold(true, true));
            document.addEventListener('touchcancel', () => cancelHold(true, true));
        }

        // --- Firebase/Offline Mode Configuration ---
        const isOfflineMode = !firebaseConfig;

        if (isOfflineMode) {
            statusIndicator.textContent = "Local Mode: Real-time syncing is disabled.";
            userIdDisplay.classList.add('text-red-600');
            startButton.disabled = false;
            startButton.classList.add('btn-primary');
            startButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
            startButton.textContent = 'Start New Race';
            joinButton.disabled = true; // Joining is not possible offline
            resetButton.addEventListener('click', () => {
                vibrate();
                location.reload();
            });

            startButton.addEventListener('click', () => {
                vibrate();
                startTimerLogic();
                renderFinishers([]);
            });

            recordButton.addEventListener('click', () => {
                vibrate();
                if (isRaceStarted) {
                    finisherCount++;
                    const finishTime = Date.now() - startTime;
                    renderFinishers([{ finisherNumber: finisherCount, finishTime: finishTime }]);

                    // Add flash effect for offline mode
                    recordButton.classList.add('flash');
                    setTimeout(() => {
                        recordButton.classList.remove('flash');
                    }, 500);
                }
            });
        } else {
            // --- ONLINE MODE: Real-time functionality with Firebase ---
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            let isAuthReady = false;
            
            statusIndicator.textContent = "Authenticating with Firebase...";

            // --- Firebase Authentication and Real-time Listener Setup ---
            onAuthStateChanged(auth, async (user) => {
                if (user && !isAuthReady) {
                    isAuthReady = true;
                    console.log("Firebase connection established and user authenticated.");
                    
                    startButton.disabled = false;
                    startButton.textContent = 'Ready to Go!';
                    startButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                    startButton.classList.add('btn-primary');
                    joinButton.disabled = false;
                    recordButton.disabled = true;
                    stopButton.disabled = true;
                    resetButton.disabled = false;
                    statusIndicator.textContent = "Status: Ready to go!";
                    userIdDisplay.textContent = `User ID: ${user.uid}`;
                    
                    attachEventListeners();
                } else if (!user) {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Error during Firebase authentication: ", error);
                        statusIndicator.textContent = "Authentication failed. Please check the console.";
                        startButton.disabled = true;
                        joinButton.disabled = true;
                        resetButton.disabled = true;
                    }
                }
            });
        }
    </script>
</body>
</html>
